{% extends "generator/base.html" %}
{% load staticfiles %}

{% block javascript %}
  <script>
    var SCALE = 5;
    var LINEWIDTH = SCALE*0.05;
    var ACTIVECOLOR = 'white';
    var INACTIVECOLOR = '#555555';

    function Room (x, y, width, height) {
      this.status = 'inactive';
      this.colors = {
        active: ACTIVECOLOR,
        inactive: INACTIVECOLOR
      };
      this.x = x*SCALE;
      this.y = y*SCALE;
      this.width = width*SCALE;
      this.height = height*SCALE;
      this.contains = function (x, y) {
        return this.x <= x && x <= this.x + this.width &&
               this.y <= y && y <= this.y + this.height;
      };
      this.draw = function (ctx) {
        if (this.status == 'active') {
          ctx.fillStyle = this.colors.active;
        } else {
          ctx.fillStyle = this.colors.inactive;
        }
        ctx.fillRect(this.x, this.y, this.width, this.height);
      };
    };
    function Corridor (path) {
      this.status = 'inactive';
      this.colors = {
        active: ACTIVECOLOR,
        inactive: INACTIVECOLOR
      };
      this.rects = [];
      for (var i = 0; i < path.length-1; i++){
        var x = path[i].x*SCALE;
        var y = path[i].y*SCALE;
        var nextX = path[i+1].x*SCALE;
        var nextY = path[i+1].y*SCALE;
        var width = Math.abs(nextX-x) || SCALE;
        var height = Math.abs(nextY-y) || SCALE;
        var rect = {
          x: x,
          y: y,
          width: width,
          height: height
        };
        this.rects.push(rect);
      }
      this.contains = function (x, y) {
        for (var i = 0; i < this.rects.length; i++) {
          var rect = this.rects[i];
          if (rect.x <= x && x <= rect.x + rect.width &&
              rect.y <= y && y <= rect.y + rect.height) {
            return true;
          }
        }
        return false;
      };
      this.draw = function (ctx) {
        if (this.status == 'active') {
          ctx.fillStyle = this.colors.active;
        } else {
          ctx.fillStyle = this.colors.inactive;
        }
        for (var i = 0; i < this.rects.length; i++) {
          var rect = this.rects[i];
          ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        }
      };
    };
    function Door (x, y, direction, status) {
      this.status = status;
      this.colors = {
        openFill: INACTIVECOLOR,
        openOutline: 'black',
        closedFill: 'black',
        closedOutline: INACTIVECOLOR
      };
      this.width = SCALE/2;
      this.height = this.width;
      var offset = SCALE/4;
      x = x*SCALE;
      y = y*SCALE;
      switch (direction) {
        case 'north':
          this.x = x+offset;
          this.y = y-offset;
          break;
        case 'south':
          this.x = x+offset;
          this.y = y-offset+SCALE;
          break;
        case 'east' :
          this.x = x-offset+SCALE;
          this.y = y+offset;
          break;
        case 'west' :
          this.x = x-offset;
          this.y = y+offset;
      }
      this.contains = function (x, y) {
        return this.x <= x && x <= this.x + this.width &&
               this.y <= y && y <= this.y + this.height;
      };
      this.draw = function(ctx) {
        if (this.status == 'open') {
          ctx.fillStyle = this.colors.openFill;
          ctx.strokeStyle = this.colors.openOutline;
        } else {
          ctx.fillStyle = this.colors.closedFill;
          ctx.strokeStyle = this.colors.closedOutline;
        }
        ctx.lineWidth=LINEWIDTH;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeRect(this.x, this.y, this.width, this.height);
      };
    };

    var rooms = [
      new Room(1, 1, 5, 5),
      new Room(7, 8, 3, 3)
    ];
    var corridors = [
      new Corridor([
        { x : 6, y : 1 },
        { x : 8, y : 1 },
        { x : 8, y : 8 }
      ])
    ];
    var doors = [
      new Door(5, 1, 'east', 'open'),
      new Door(1, 1, 'west', 'closed'),
      new Door(8, 8, 'north', 'open'),
      new Door(9, 10, 'east', 'closed')
    ];
    
    var dungeonMapper = {
      canvas : document.getElementById("canvas"),
      transforms : {
        scaleFactor : 5.00,
        panX : 0,
        panY : 0,
        prevPanX : 0,
        prevPanY : 0
      },
      start: function () {
        this.context = this.canvas.getContext("2d");
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this), false);
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this), false);
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this), false);
        this.canvas.addEventListener('DOMMouseScroll', this.handleScroll.bind(this), false);
        this.canvas.addEventListener('mousewheel', this.handleScroll.bind(this), false);
        this.draw();
      },
      getMousePos: function (e, canvas) {
        var rect = canvas.getBoundingClientRect();
        var rawX = e.clientX - rect.left;
        var rawY = e.clientY - rect.top
        var transformedX = rawX/this.transforms.scaleFactor-this.transforms.prevPanX;
        var transformedY = rawY/this.transforms.scaleFactor-this.transforms.prevPanY;
        return {
          x: transformedX,
          y: transformedY
        };
      },
      handleMouseDown: function (e) {
        this.mouseIsDown = true;
        this.prevMouseDownPos = this.getMousePos(e, this.canvas);
        return e.preventDefault() && false;
      },
      handleMouseUp: function (e) {
        this.mouseIsDown = false;
        var mousePos = this.getMousePos(e, this.canvas);
        this.transforms.prevPanX += mousePos.x - this.prevMouseDownPos.x;
        this.transforms.prevPanY += mousePos.y - this.prevMouseDownPos.y;
        return e.preventDefault() && false;
      },
      handleMouseMove: function (e) {
        var mousePos = this.getMousePos(e, this.canvas);
        if (this.mouseIsDown) {
          this.handleDrag(mousePos);
        } else {
          this.handleHover(mousePos);
        }
        this.draw(); //TODO: should only draw if anything changes
        return e.preventDefault() && false;
      },
      handleDrag: function (mousePos) {
        this.transforms.panX = this.transforms.prevPanX + mousePos.x - this.prevMouseDownPos.x;
        this.transforms.panY = this.transforms.prevPanY + mousePos.y - this.prevMouseDownPos.y;
      },
      handleHover: function (mousePos) {
        for (var i = 0; i < this.rooms.length; i++){
          var room = this.rooms[i];
          if (room.contains(mousePos.x, mousePos.y)) {
            room.status = 'active';
          } else {
            room.status = 'inactive';
          }
        }
        for (var i = 0; i < this.corridors.length; i++){
          var corridor = this.corridors[i];
          if (corridor.contains(mousePos.x, mousePos.y)) {
            corridor.status = 'active';
          } else {
            corridor.status = 'inactive';
          }
        }
      },
      handleScroll: function(e){
        var delta = e.wheelDelta ? e.wheelDelta/120 : 0;
        if (delta) this.zoom(delta);
        return e.preventDefault() && false;
      },
      zoom: function(delta){
        //TODO: translate during zoom based on mouse position
        var factor = 1+delta/10;
        this.transforms.scaleFactor *= factor;
        this.draw();
      },
      drawGrid: function () {
        var ctx = this.context;
        for (var i = SCALE; i < this.canvas.width; i+=SCALE) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, this.canvas.height);
          ctx.lineWidth=LINEWIDTH;
          ctx.strokeStyle = 'black';
          ctx.stroke();
        }
        for (var i = SCALE; i < this.canvas.height; i+=SCALE) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(this.canvas.width, i);
          ctx.lineWidth=LINEWIDTH;
          ctx.strokeStyle = 'black';
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this.context;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save();
        ctx.scale(this.transforms.scaleFactor, this.transforms.scaleFactor);
        ctx.translate(this.transforms.panX, this.transforms.panY);
        for (var i = 0; i < this.rooms.length; i++) {
          this.rooms[i].draw(ctx);
        }
        for (var i = 0; i < this.corridors.length; i++) {
          this.corridors[i].draw(ctx);
        }
        this.drawGrid();
        for (var i = 0; i < this.doors.length; i++) {
          this.doors[i].draw(ctx);
        }
        ctx.restore();
      }
    };

    dungeonMapper.rooms = rooms;
    dungeonMapper.corridors = corridors;
    dungeonMapper.doors = doors;
    dungeonMapper.start();
  </script>
{% endblock %}

{% block content %}

<div class="container">
  <div class="row">
  	<div class="col-md-12 text-center">
  		<h1>Canvas Test</h1>
  		<div>- Generate Infinite Content -</div>
  	</div>
    <div class="col-md-12">
      <canvas id="canvas" width="500" height="500" style="border:1px solid #000000;">
      </canvas>
    </div>
  </div> <!-- row -->
</div> <!-- container -->

{% endblock %}