{% extends "generator/base.html" %}
{% load staticfiles %}

{% block javascript %}
  <script>
    var SCALE = 5;
    var LINEWIDTH = SCALE*0.05;
    var ACTIVECOLOR = 'white';
    var HOVERCOLOR= '#aaaaaa';
    var INACTIVECOLOR = '#555555';

    function Room (x, y, width, height, isActive, id) {
      this.id = id;
      this.isActive = isActive;
      this.hover = false;
      this.colors = {
        active: ACTIVECOLOR,
        hover: HOVERCOLOR,
        inactive: INACTIVECOLOR
      };
      this.x = x*SCALE;
      this.y = y*SCALE;
      this.width = width*SCALE;
      this.height = height*SCALE;
      this.contains = function (x, y) {
        return this.x <= x && x <= this.x + this.width &&
               this.y <= y && y <= this.y + this.height;
      };
      this.draw = function (ctx) {
        if (this.isActive) {
          ctx.fillStyle = this.colors.active;
        } else if (this.hover) {
          ctx.fillStyle = this.colors.hover;
        } else {
          ctx.fillStyle = this.colors.inactive
        }
        ctx.fillRect(this.x, this.y, this.width, this.height);
      };
    };

    function Corridor (path, isActive, id) {
      this.id = id;
      this.isActive = isActive;
      this.hover = false;
      this.colors = {
        active: ACTIVECOLOR,
        hover: HOVERCOLOR,
        inactive: INACTIVECOLOR
      };
      this.rects = [];
      for (var i = 0; i < path.length-1; i++){
        var x = path[i].x*SCALE;
        var y = path[i].y*SCALE;
        var nextX = path[i+1].x*SCALE;
        var nextY = path[i+1].y*SCALE;
        var width = Math.abs(nextX-x) || SCALE;
        var height = Math.abs(nextY-y) || SCALE;
        var rect = {
          x: x,
          y: y,
          width: width,
          height: height
        };
        this.rects.push(rect);
      }
      this.contains = function (x, y) {
        for (var i = 0; i < this.rects.length; i++) {
          var rect = this.rects[i];
          if (rect.x <= x && x <= rect.x + rect.width &&
              rect.y <= y && y <= rect.y + rect.height) {
            return true;
          }
        }
        return false;
      };
      this.draw = function (ctx) {
        if (this.isActive) {
          ctx.fillStyle = this.colors.active;
        } else if (this.hover) {
          ctx.fillStyle = this.colors.hover;
        } else {
          ctx.fillStyle = this.colors.inactive;
        }
        for (var i = 0; i < this.rects.length; i++) {
          var rect = this.rects[i];
          ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        }
      };
    };

    function Door (x, y, direction, isOpen, id) {
      this.id = id;
      this.isOpen = isOpen;
      this.colors = {
        openFill: INACTIVECOLOR,
        openOutline: 'black',
        closedFill: 'black',
        closedOutline: INACTIVECOLOR
      };
      this.width = SCALE/2;
      this.height = this.width;
      var offset = SCALE/4;
      x = x*SCALE;
      y = y*SCALE;
      switch (direction) {
        case 'north':
          this.x = x+offset;
          this.y = y-offset;
          break;
        case 'south':
          this.x = x+offset;
          this.y = y-offset+SCALE;
          break;
        case 'east' :
          this.x = x-offset+SCALE;
          this.y = y+offset;
          break;
        case 'west' :
          this.x = x-offset;
          this.y = y+offset;
      }
      this.contains = function (x, y) {
        return this.x <= x && x <= this.x + this.width &&
               this.y <= y && y <= this.y + this.height;
      };
      this.draw = function(ctx) {
        if (this.isOpen) {
          ctx.fillStyle = this.colors.openFill;
          ctx.strokeStyle = this.colors.openOutline;
        } else {
          ctx.fillStyle = this.colors.closedFill;
          ctx.strokeStyle = this.colors.closedOutline;
        }
        ctx.lineWidth=LINEWIDTH;
        ctx.fillRect(this.x, this.y, this.width, this.height);
        ctx.strokeRect(this.x, this.y, this.width, this.height);
      };
    };

    // var rooms = [
    //   new Room(1, 1, 5, 5, false, 1),
    //   new Room(7, 8, 3, 3, false, 2)
    // ];
    // var corridors = [
    //   new Corridor([
    //     { x : 6, y : 1 },
    //     { x : 8, y : 1 },
    //     { x : 8, y : 8 }
    //   ], false, 1)
    // ];
    // var doors = [
    //   new Door(5, 1, 'east', true, 1),
    //   new Door(1, 1, 'west', false, 2),
    //   new Door(8, 8, 'north', true, 3),
    //   new Door(9, 10, 'east', false, 4)
    // ];
    
    var dungeonMapper = {
      canvas : document.getElementById("canvas"),
      transforms : {
        scaleFactor : 5.00,
        panX : 0,
        panY : 0,
        prevPanX : 0,
        prevPanY : 0
      },
      start: function () {
        this.context = this.canvas.getContext("2d");
        this.canvas.addEventListener('click', this.handleClick.bind(this), false);
        this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this), false);
        this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this), false);
        this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this), false);
        this.canvas.addEventListener('DOMMouseScroll', this.handleScroll.bind(this), false);
        this.canvas.addEventListener('mousewheel', this.handleScroll.bind(this), false);
        this.canvas.addEventListener('contextmenu', this.handleRightClick.bind(this), false);
        this.draw();
      },
      getMousePos: function (e, canvas) {
        var rect = canvas.getBoundingClientRect();
        var rawX = e.clientX - rect.left;
        var rawY = e.clientY - rect.top
        var transformedX = rawX/this.transforms.scaleFactor-this.transforms.prevPanX;
        var transformedY = rawY/this.transforms.scaleFactor-this.transforms.prevPanY;
        return {
          x: transformedX,
          y: transformedY
        };
      },
      checkCollisions: function (components, mousePos, callback) {
        //TODO: it is currently possible to hover/click on two neighboring components at once
        for (var i = 0; i < components.length; i++){
          var isColliding = components[i].contains(mousePos.x, mousePos.y) ? true : false;
          callback(components[i], isColliding);
        }
      },
      handleClick: function (e) {
        //TODO: don't set components to active if the user was dragging to pan the view
        //TODO: clicking a door shouldn't affect the components beneath it
        e.preventDefault();
        var mousePos = this.getMousePos(e, this.canvas);
        this.checkCollisions(this.doors, mousePos, function(door, isColliding) {
          if (isColliding) {
            door.isOpen = !door.isOpen;
            console.log("door #: " + door.id);
          }
        });
        this.checkCollisions(this.rooms, mousePos, function(room, isColliding) {
          if (isColliding) {
            room.isActive = true;
            console.log(room.id);
          } else {
            room.isActive = false;
          }
        });
        this.checkCollisions(this.corridors, mousePos, function(corridor, isColliding) {
          if (isColliding) {
            corridor.isActive = true;
            console.log(corridor.id);
          } else {
            corridor.isActive = false;
          }
        });
        this.draw();
      },
      handleRightClick: function (e) {
        e.preventDefault();
        console.log("right clicked");
      },
      handleMouseDown: function (e) {
        e.preventDefault();
        this.mouseIsDown = true;
        this.prevMouseDownPos = this.getMousePos(e, this.canvas);
      },
      handleMouseUp: function (e) {
        e.preventDefault();
        this.mouseIsDown = false;
        var mousePos = this.getMousePos(e, this.canvas);
        this.transforms.prevPanX += mousePos.x - this.prevMouseDownPos.x;
        this.transforms.prevPanY += mousePos.y - this.prevMouseDownPos.y;
      },
      handleMouseMove: function (e) {
        e.preventDefault();
        var mousePos = this.getMousePos(e, this.canvas);
        if (this.mouseIsDown) {
          this.handleDrag(mousePos);
        } else {
          this.handleHover(mousePos);
        }
        this.draw(); //TODO: use animationFrame instead of manually calling draw()
      },
      handleDrag: function (mousePos) {
        this.transforms.panX = this.transforms.prevPanX + mousePos.x - this.prevMouseDownPos.x;
        this.transforms.panY = this.transforms.prevPanY + mousePos.y - this.prevMouseDownPos.y;
      },
      handleHover: function (mousePos) {
        this.checkCollisions(this.rooms, mousePos, function(room, isColliding){
          if (isColliding) {
            room.hover = true;
          } else {
            room.hover = false;
          }
        });
        this.checkCollisions(this.corridors, mousePos, function(corridor, isColliding){
          if (isColliding) {
            corridor.hover = true;
          } else {
            corridor.hover = false;
          }
        });
      },
      handleScroll: function(e){
        //TODO: translate during zoom based on mouse position
        e.preventDefault();
        var delta = e.wheelDelta ? e.wheelDelta/120 : 0;
        if (delta) {
          var factor = 1+delta/10;
          this.transforms.scaleFactor *= factor;
          this.draw();
        }
      },
      drawGrid: function () {
        var ctx = this.context;
        for (var i = SCALE; i < this.canvas.width; i+=SCALE) {
          ctx.beginPath();
          ctx.moveTo(i, 0);
          ctx.lineTo(i, this.canvas.height);
          ctx.lineWidth=LINEWIDTH;
          ctx.strokeStyle = 'black';
          ctx.stroke();
        }
        for (var i = SCALE; i < this.canvas.height; i+=SCALE) {
          ctx.beginPath();
          ctx.moveTo(0, i);
          ctx.lineTo(this.canvas.width, i);
          ctx.lineWidth=LINEWIDTH;
          ctx.strokeStyle = 'black';
          ctx.stroke();
        }
      },
      draw: function () {
        var ctx = this.context;
        ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
        ctx.save();
        ctx.scale(this.transforms.scaleFactor, this.transforms.scaleFactor);
        ctx.translate(this.transforms.panX, this.transforms.panY);
        for (var i = 0; i < this.rooms.length; i++) {
          this.rooms[i].draw(ctx);
        }
        for (var i = 0; i < this.corridors.length; i++) {
          this.corridors[i].draw(ctx);
        }
        this.drawGrid();
        for (var i = 0; i < this.doors.length; i++) {
          this.doors[i].draw(ctx);
        }
        ctx.restore();
      }
    };

    $(function() {
      $.ajax({
        url: '/ajax/map_data/',
        dataType: 'json',
        success: handleRequest
      });
    });

    function handleRequest(data) {
      var rooms = data.rooms.map(function(r) {
        return new Room(r.x, r.y, r.width, r.height, r.isActive, 1);
      });
      console.log(rooms[0]);
      dungeonMapper.rooms = rooms;
      dungeonMapper.corridors = [];
      dungeonMapper.doors = [];
      dungeonMapper.start();
    }
  </script>
{% endblock %}

{% block content %}

<div class="container">
  <div class="row">
  	<div class="col-md-12 text-center">
  		<h1>Canvas Test</h1>
  		<div>- Generate Infinite Content -</div>
  	</div>
    <div class="col-md-12">
      <canvas id="canvas" width="500" height="500" style="border:1px solid #000000;">
      </canvas>
    </div>
  </div> <!-- row -->
</div> <!-- container -->

{% endblock %}